# Chessbot.py

## 1. Алгоритм поиска: Негамакс с альфа-бета отсечением
Алгоритм [Негамакс](docs\details\negamax.md) является оптимизированной версией Минмакса, применяемой в симметричных играх, таких как шахматы. В основе алгоритма лежит поиск в дереве ходов, где бот выбирает оптимальный ход, минимизируя наихудший возможный результат.

#### Пример из кода:
```python
def negamax(self, board, depth, alpha, beta, color):
    if depth == 0 or board.is_game_over():
        evaluation, evaluation_details = evaluate_board(board, logging=self.logging)
        return color * evaluation, evaluation_details
```

Здесь:
- `depth` задает глубину поиска.
- `alpha` и `beta` используются для отсечения неэффективных ходов, что сокращает число проверяемых позиций и повышает производительность.
- `color` определяет текущий игрок (белый или черный).

### 2. Альфа-бета отсечение
Альфа-бета отсечение используется для сокращения количества просматриваемых ходов. Если текущий ход оказывается хуже ранее рассмотренного, дальнейший его анализ не производится.

#### Пример из кода:
```python
alpha = max(alpha, eval)
if alpha >= beta:
    break  # Alpha-beta отсечение
```

### 3. Оценка позиции
Функция `evaluate_board` (из файла `evaluator.py`) анализирует текущее положение фигур на доске и возвращает численное значение, отражающее выгодность позиции для текущего игрока. Оценка может учитывать:
- **Материальные соотношения** — сколько весовых фигур на доске.
- **Позиционные факторы** — такие как центрирование фигур, защита короля и активность фигур.

---

## Структура кода

### 1. Класс `ChessBot`
Основной класс проекта, представляющий шахматного бота. 

- **Атрибуты**
  - `depth`: глубина поиска для алгоритма Негамакс.
  - `logging`: параметр для включения режима логирования.
  - `position_history`, `transposition_table`, `killer_moves`, `history_heuristic`: данные структуры для оптимизации поиска.

### 2. Метод `find_best_move`
Этот метод находит лучший ход, ограниченный по времени. В режиме многократного запуска с возрастанием глубины (итеративное углубление) бот анализирует ходы, увеличивая сложность, пока не истечет максимальное время поиска.

#### Пример из кода:
```python
def find_best_move(self, board, max_time=5):
    start_time = time.time()
    for depth in range(1, self.depth + 1):
        if time.time() - start_time > max_time:
            break
        eval, move = self.negamax(board, depth, -math.inf, math.inf, 1 if board.turn == chess.WHITE else -1)
```

---

## Примеры и детали логирования

Для диагностики и отладки реализовано логирование, выводящее информацию о каждом ходе и его оценке в формате таблицы. При включении логирования (аргумент `logging=True`) функция `log_evaluation` будет выводить оценки в удобном табличном формате.

#### Пример использования логирования:
```python
def log_evaluation(self, board, evaluation, evaluation_details):
    move = board.peek() if board.move_stack else "Начальная позиция"
    table_data = [[move] + list(evaluation_details.values())]
    print(tabulate(table_data, tablefmt='orgtbl'))
```